# Accustoming yourself to c++

## 01 - 视C++为一个语言联邦

为了认识并理解c++，必需认识其主要的次语言（sub-language）：

- C。说到底C++仍是以C为基础。区块（blocks）、语句（statement）、预处理（preprocessor）、内置数据类型（build-in data types）、数组（arrays）、指针（pointers）等统统来自C。而C语言有高效编程下的局限：没有模板（templates），没有异常（exceptions），没有重载（overloading）...

- Object-Oriented C++。面向对象编程三要素：封装、继承和多态。

- Template C++。

- STL。

请记住：C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。

## 02 - 尽量以 const，enum，inline替换 #define

理由：

- 编译错误不容易排查

- 定义常量指针，不能使用define

- 使用class专属常量，不能使用define

- define没有封装性，因为define没有作用域scope

- define定义函数会有不安全性，可以用template inline代替

记住：

- 对于单纯常量，最好以const对象或enums替换#define

- 对于形似函数的宏macros，最好改用inline函数替换#define

## 03 - 尽可能使用const

使用场景及作用包括：

- 任何作用域内的对象：用来声明某个变量是否应该constant的，处理指针变量时需要注意一些语法
- 函数的入参：可以使得该参数在函数内是否是constant的
- 函数的返回类型：可以防止用户有些无意义的操作，比如拿函数的返回值进行赋值操作
- 成员函数本体：可以通过类对象的const特性来选择调用const函数或者non-const函数

记住：

- 当const 和 non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复

## 04 - 确定对象被使用前已经被初始化

必要性：

- 目前规则是“对象的初始化动作何时一定发生，何时不一定发生”。不幸的是这些规则很复杂，对于记忆来说太繁复了些，比如C的特性中有些数据结构就不需要初始化（因为初始化会招致运行期成本）而STL部分则需要初始化。所以，为了规避繁复的记忆，鼓励对所有对象被使用前被初始化

注意：

- 注意赋值（assignment）和初始化（initialization）的区别。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前,但是不保证内置变量的操作顺序

- 对于一个包含其他类对象的对象构造函数的较佳写法是，使用所谓的member initialization list（成员初值列）替换赋值操作，可以避免初始化操作浪费效率；对于内置类型来说，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化

- 所以可以立下一个规则：规定总是在初值列中列出所有成员变量，以免还得记住哪些成员变量可以无需赋值

- 虽然内置类型的初始化和赋值的成本相同，但是如果其为const或者references，它们就一定需要初值，不能被赋值

- 有的情况下，class会拥有多个构造函数，如果每个构造函数都有成员初值列，那么会带来很多重复的无聊的工作，这个时候可以定义一个private member function，把赋值和初始化成本一样的变量的赋值操作写在里头

- 需要注意在不同编译单元中的两个依赖的non-local static对象的初始化次序，一般无法确定其初始化顺序，幸运的是有一个小小的设计便可完全消除这个问题：将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static即可），这种解决方案在单线程程序中起码是适用的